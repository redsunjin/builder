#!/usr/bin/env python3
"""
Smoke test for orchestrator reliability guarantees.

Checks:
1) run_pipeline returns API-compatible payload.
2) temp worktrees are cleaned up after completion.
3) the latest run journal is finalized with no remaining resources.
"""

import argparse
import glob
import json
import os
import subprocess
import sys
import time


SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, ".."))
if REPO_ROOT not in sys.path:
    sys.path.append(REPO_ROOT)

from core.orchestrator import Orchestrator
from scripts.git_manager import GitManager


def list_temp_worktrees(git_manager: GitManager) -> list:
    items = []
    for entry in git_manager.list_worktrees():
        path = entry.get("path")
        if not path:
            continue
        rel = os.path.relpath(os.path.abspath(path), REPO_ROOT).replace("\\", "/")
        if rel.startswith("worktrees/temp_"):
            items.append(path)
    return sorted(items)


def find_latest_journal(journal_dir: str, started_at: float) -> str:
    candidates = []
    for path in glob.glob(os.path.join(journal_dir, "run_*.json")):
        try:
            mtime = os.path.getmtime(path)
        except OSError:
            continue
        if mtime >= started_at - 1.0:
            candidates.append((mtime, path))

    if not candidates:
        return ""
    candidates.sort(key=lambda item: item[0], reverse=True)
    return candidates[0][1]


def get_head_sha(repo_root: str) -> str:
    output = subprocess.check_output(
        ["git", "rev-parse", "HEAD"],
        cwd=repo_root,
        text=True,
    )
    return output.strip()


def main() -> int:
    parser = argparse.ArgumentParser(description="Run orchestrator reliability smoke test.")
    parser.add_argument(
        "--intent",
        default="헤더와 버튼 하나 만들어줘",
        help="User intent used for smoke pipeline run",
    )
    parser.add_argument(
        "--allow-merge",
        action="store_true",
        help="Allow merge to main during smoke run (unsafe for routine checks).",
    )
    args = parser.parse_args()

    disable_merge = not args.allow_merge
    os.environ["ORCHESTRATOR_DISABLE_MERGE"] = "1" if disable_merge else "0"
    print(
        "[mode] ORCHESTRATOR_DISABLE_MERGE="
        f"{os.environ['ORCHESTRATOR_DISABLE_MERGE']}"
    )

    git_manager = GitManager(REPO_ROOT)
    head_before = get_head_sha(REPO_ROOT)
    before_temp = list_temp_worktrees(git_manager)
    if before_temp:
        print(f"[warn] existing temp worktrees before smoke: {before_temp}")

    started_at = time.time()
    orchestrator = Orchestrator()
    session_id = f"smoke_reliability_{int(started_at)}"
    result = orchestrator.run_pipeline(session_id, args.intent)

    if not isinstance(result, dict) or "html" not in result or "metrics" not in result:
        raise RuntimeError("run_pipeline did not return expected API payload (html + metrics).")

    after_temp = list_temp_worktrees(git_manager)
    if after_temp:
        raise RuntimeError(f"temp worktrees remain after run: {after_temp}")

    journal_dir = orchestrator.journal_dir
    latest_journal = find_latest_journal(journal_dir, started_at)
    if not latest_journal:
        raise RuntimeError("could not locate a run journal generated by this smoke run.")

    with open(latest_journal, "r", encoding="utf-8") as f:
        journal_payload = json.load(f)

    status = journal_payload.get("status")
    if status not in {"completed", "blocked", "interrupted"}:
        raise RuntimeError(f"unexpected journal status: {status}")

    resources = journal_payload.get("resources", [])
    if resources:
        raise RuntimeError(f"journal still contains active resources: {resources}")

    head_after = get_head_sha(REPO_ROOT)
    if disable_merge and head_after != head_before:
        raise RuntimeError(
            "HEAD changed while merge was disabled. "
            f"before={head_before} after={head_after}"
        )

    print("[ok] reliability smoke passed")
    print(f"[ok] journal={os.path.basename(latest_journal)} status={status}")
    print(f"[ok] head_before={head_before} head_after={head_after}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
