#!/usr/bin/env python3
"""
Smoke test for orchestrator reliability guarantees.

Checks:
1) run_pipeline returns API-compatible payload.
2) temp worktrees are cleaned up after completion.
3) the latest run journal is finalized with no remaining resources.
"""

import argparse
import glob
import json
import os
import sys
import time


SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
REPO_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, ".."))
if REPO_ROOT not in sys.path:
    sys.path.append(REPO_ROOT)

from core.orchestrator import Orchestrator
from scripts.git_manager import GitManager


def list_temp_worktrees(git_manager: GitManager) -> list:
    items = []
    for entry in git_manager.list_worktrees():
        path = entry.get("path")
        if not path:
            continue
        rel = os.path.relpath(os.path.abspath(path), REPO_ROOT).replace("\\", "/")
        if rel.startswith("worktrees/temp_"):
            items.append(path)
    return sorted(items)


def find_latest_journal(journal_dir: str, started_at: float) -> str:
    candidates = []
    for path in glob.glob(os.path.join(journal_dir, "run_*.json")):
        try:
            mtime = os.path.getmtime(path)
        except OSError:
            continue
        if mtime >= started_at - 1.0:
            candidates.append((mtime, path))

    if not candidates:
        return ""
    candidates.sort(key=lambda item: item[0], reverse=True)
    return candidates[0][1]


def main() -> int:
    parser = argparse.ArgumentParser(description="Run orchestrator reliability smoke test.")
    parser.add_argument(
        "--intent",
        default="헤더와 버튼 하나 만들어줘",
        help="User intent used for smoke pipeline run",
    )
    args = parser.parse_args()

    git_manager = GitManager(REPO_ROOT)
    before_temp = list_temp_worktrees(git_manager)
    if before_temp:
        print(f"[warn] existing temp worktrees before smoke: {before_temp}")

    started_at = time.time()
    orchestrator = Orchestrator()
    result = orchestrator.run_pipeline("smoke_reliability_session", args.intent)

    if not isinstance(result, dict) or "html" not in result or "metrics" not in result:
        raise RuntimeError("run_pipeline did not return expected API payload (html + metrics).")

    after_temp = list_temp_worktrees(git_manager)
    if after_temp:
        raise RuntimeError(f"temp worktrees remain after run: {after_temp}")

    journal_dir = os.path.join(REPO_ROOT, "output", "orchestrator_runs")
    latest_journal = find_latest_journal(journal_dir, started_at)
    if not latest_journal:
        raise RuntimeError("could not locate a run journal generated by this smoke run.")

    with open(latest_journal, "r", encoding="utf-8") as f:
        journal_payload = json.load(f)

    status = journal_payload.get("status")
    if status not in {"completed", "blocked", "interrupted"}:
        raise RuntimeError(f"unexpected journal status: {status}")

    resources = journal_payload.get("resources", [])
    if resources:
        raise RuntimeError(f"journal still contains active resources: {resources}")

    print("[ok] reliability smoke passed")
    print(f"[ok] journal={os.path.basename(latest_journal)} status={status}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
